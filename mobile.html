<!DOCTYPE html>
<html lang="ko">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Í≥ºÏùº Ìï©ÏπòÍ∏∞ Í≤åÏûÑ</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.19.0/matter.min.js"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Noto+Sans+KR:wght@400;700&display=swap');

        :root {
            --bg-gradient: linear-gradient(135deg, #fdfbfb 0%, #ebedee 100%);
            --card-bg: #ffffff;
            --text-primary: #2d3436;
            --text-secondary: #636e72;
            --accent-color: #ff7675;
            /* Soft Red/Coral */
            --border-radius: 24px;
            --shadow-soft: 0 10px 40px rgba(0, 0, 0, 0.08);
            --shadow-sharp: 0 4px 12px rgba(0, 0, 0, 0.1);
        }

        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
            font-family: 'Noto Sans KR', sans-serif;
            user-select: none;
            -webkit-user-select: none;
        }

        body {
            background: var(--bg-gradient);
            color: var(--text-primary);
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            overflow: hidden;
            /* Prevent scroll on mobile */
        }

        .game-container {
            position: relative;
            width: 100%;
            max-width: 480px;
            /* Slightly wider */
            height: 95vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 0 20px;
        }

        /* Header / HUD */
        header {
            width: 100%;
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 15px 25px;
            background-color: var(--card-bg);
            border-radius: 20px;
            margin-bottom: 20px;
            box-shadow: var(--shadow-sharp);
            z-index: 10;
        }

        .score-board {
            font-size: 1.1rem;
            font-weight: 700;
            color: var(--text-primary);
        }

        .score-board span#score {
            color: var(--accent-color);
            font-size: 1.4rem;
            margin-left: 5px;
        }

        .next-fruit {
            display: flex;
            align-items: center;
            gap: 12px;
            font-weight: 700;
            color: var(--text-secondary);
        }

        #next-fruit-display {
            width: 42px;
            height: 42px;
            background-color: #f1f2f6;
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            box-shadow: inset 0 2px 5px rgba(0, 0, 0, 0.05);
        }

        /* Game Area */
        #game-area {
            position: relative;
            width: 100%;
            flex-grow: 1;
            background-color: rgba(255, 255, 255, 0.6);
            /* Semi-transparent */
            backdrop-filter: blur(10px);
            border: 2px solid rgba(255, 255, 255, 0.8);
            border-radius: 0 0 var(--border-radius) var(--border-radius);
            box-shadow: var(--shadow-soft);
            overflow: hidden;
        }

        /* Canvas will be injected by Matter.js here */
        canvas {
            display: block;
            margin: 0 auto;
        }

        /* Legend */
        .fruit-legend {
            margin-top: 20px;
            background-color: var(--card-bg);
            padding: 15px 20px;
            border-radius: 20px;
            box-shadow: var(--shadow-sharp);
            width: 100%;
            text-align: center;
        }

        .fruit-legend h3 {
            margin-bottom: 12px;
            color: var(--text-secondary);
            font-size: 0.9rem;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .legend-items {
            display: flex;
            justify-content: center;
            align-items: center;
            flex-wrap: nowrap;
            /* Force single line if possible, or scroll */
            gap: 8px;
            overflow-x: auto;
            /* Allow scroll on very small screens */
            padding-bottom: 5px;
        }

        .legend-item {
            display: flex;
            align-items: center;
            font-size: 1.3rem;
            opacity: 0.8;
        }

        .legend-item:last-child {
            opacity: 1;
            font-size: 1.5rem;
            /* Emphasize watermelon */
        }

        .legend-item .arrow {
            font-size: 0.8rem;
            color: #dfe6e9;
            margin: 0 4px;
        }

        /* Game Over Modal */
        .hidden {
            display: none !important;
        }

        #game-over {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: var(--card-bg);
            padding: 50px 40px;
            border-radius: 30px;
            text-align: center;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.2);
            z-index: 100;
            width: 85%;
            max-width: 320px;
            animation: popIn 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        }

        @keyframes popIn {
            from {
                opacity: 0;
                transform: translate(-50%, -40%) scale(0.9);
            }

            to {
                opacity: 1;
                transform: translate(-50%, -50%) scale(1);
            }
        }

        #game-over h2 {
            font-size: 2rem;
            color: var(--text-primary);
            margin-bottom: 10px;
        }

        #game-over p {
            font-size: 1.2rem;
            color: var(--text-secondary);
            margin-bottom: 30px;
        }

        #final-score {
            color: var(--accent-color);
            font-weight: 700;
            font-size: 1.5rem;
        }

        #restart-btn {
            width: 100%;
            padding: 15px;
            font-size: 1.1rem;
            font-weight: 700;
            background-color: var(--accent-color);
            border: none;
            border-radius: 12px;
            color: white;
            cursor: pointer;
            box-shadow: 0 4px 15px rgba(255, 118, 117, 0.4);
            transition: transform 0.1s, box-shadow 0.1s;
        }

        #restart-btn:active {
            transform: scale(0.98);
            box-shadow: 0 2px 10px rgba(255, 118, 117, 0.3);
        }
    </style>
</head>

<body>
    <div class="game-container">
        <header>
            <div class="score-board">
                <span>Ï†êÏàò: <span id="score">0</span></span>
            </div>
            <div class="next-fruit">
                <span>Îã§Ïùå:</span>
                <div id="next-fruit-display"></div>
            </div>
        </header>

        <div id="game-area"></div>

        <div class="fruit-legend">
            <h3>Í≥ºÏùº ÏßÑÌôî ÏàúÏÑú</h3>
            <div class="legend-items">
                <!-- Items will be populated by CSS/HTML directly for simplicity -->
                <div class="legend-item"><span>üçá</span><span class="arrow">‚Üí</span></div>
                <div class="legend-item"><span>üçì</span><span class="arrow">‚Üí</span></div>
                <div class="legend-item"><span>üçä</span><span class="arrow">‚Üí</span></div>
                <div class="legend-item"><span>üçå</span><span class="arrow">‚Üí</span></div>
                <div class="legend-item"><span>üçë</span><span class="arrow">‚Üí</span></div>
                <div class="legend-item"><span>üçà</span><span class="arrow">‚Üí</span></div>
                <div class="legend-item"><span>üçâ</span></div>
            </div>
        </div>

        <div id="game-over" class="hidden">
            <h2>Í≤åÏûÑ Ïò§Î≤Ñ!</h2>
            <p>ÏµúÏ¢Ö Ï†êÏàò: <span id="final-score">0</span></p>
            <button id="restart-btn">Îã§Ïãú ÏãúÏûë</button>
        </div>
    </div>
    <script>
        const Engine = Matter.Engine,
            Render = Matter.Render,
            Runner = Matter.Runner,
            World = Matter.World,
            Bodies = Matter.Bodies,
            Events = Matter.Events,
            Composite = Matter.Composite;

        // Fruit configuration
        const FRUITS = [
            { name: "grape", radius: 15, score: 10, color: "#8e44ad", emoji: "üçá" },
            { name: "strawberry", radius: 25, score: 20, color: "#e74c3c", emoji: "üçì" },
            { name: "tangerine", radius: 35, score: 30, color: "#e67e22", emoji: "üçä" },
            { name: "banana", radius: 45, score: 40, color: "#f1c40f", emoji: "üçå" },
            { name: "peach", radius: 60, score: 50, color: "#ff9ff3", emoji: "üçë" },
            { name: "melon", radius: 80, score: 60, color: "#2ecc71", emoji: "üçà" },
            { name: "watermelon", radius: 100, score: 70, color: "#27ae60", emoji: "üçâ" }
        ];

        let currentFruit = null;
        let nextFruitIndex = 0;
        let score = 0;
        let isGameOver = false;
        let canDrop = true;

        const engine = Engine.create();
        const world = engine.world;

        // DOM Elements
        const scoreElement = document.getElementById("score");
        const nextFruitDisplay = document.getElementById("next-fruit-display");
        const gameArea = document.getElementById("game-area");
        const gameOverScreen = document.getElementById("game-over");
        const finalScoreElement = document.getElementById("final-score");
        const restartBtn = document.getElementById("restart-btn");

        // Canvas setup
        const render = Render.create({
            element: gameArea,
            engine: engine,
            options: {
                width: 450,
                height: 600,
                wireframes: false,
                background: 'transparent',
                pixelRatio: window.devicePixelRatio
            }
        });

        // Boundary Walls
        const floor = Bodies.rectangle(225, 610, 450, 20, {
            isStatic: true,
            render: { visible: false }
        });
        const leftWall = Bodies.rectangle(-10, 300, 20, 600, {
            isStatic: true,
            render: { visible: false }
        });
        const rightWall = Bodies.rectangle(460, 300, 20, 600, {
            isStatic: true,
            render: { visible: false }
        });
        const topSensor = Bodies.rectangle(225, 0, 450, 2, {
            isStatic: true,
            isSensor: true,
            render: { visible: false },
            label: "topSensor"
        });

        World.add(world, [floor, leftWall, rightWall, topSensor]);

        Render.run(render);
        const runner = Runner.create();
        Runner.run(runner, engine);

        // Game Logic
        function initGame() {
            World.clear(world); // Clears all bodies
            Engine.clear(engine); // Clears engine state

            // Re-add static bodies
            World.add(world, [floor, leftWall, rightWall, topSensor]);

            score = 0;
            isGameOver = false;
            canDrop = true;
            updateScore(0);
            gameOverScreen.classList.add("hidden");

            spawnNextFruit(); // Prepare the first fruit
        }

        function spawnNextFruit() {
            // Determine next fruit (random small fruit: grape to tangerine)
            const randomIndex = Math.floor(Math.random() * 3);
            nextFruitIndex = randomIndex;

            // Update next fruit display
            const nextFruit = FRUITS[nextFruitIndex];
            nextFruitDisplay.innerHTML = `<span style="font-size: 24px;">${nextFruit.emoji}</span>`;
        }

        function createFruit(x, y, index, isStatic = false) {
            const fruit = FRUITS[index];
            const body = Bodies.circle(x, y, fruit.radius, {
                restitution: 0.2,
                render: {
                    fillStyle: fruit.color
                },
                label: "fruit_" + index
            });
            return body;
        }

        // Custom Renderer for Emojis
        Events.on(render, 'afterRender', function () {
            const context = render.context;
            const bodies = Composite.allBodies(engine.world);

            context.font = "30px Arial";
            context.textAlign = "center";
            context.textBaseline = "middle";

            for (let i = 0; i < bodies.length; i += 1) {
                const body = bodies[i];
                if (body.label.startsWith('fruit_')) {
                    const index = parseInt(body.label.split('_')[1]);
                    const fruit = FRUITS[index];

                    context.save();
                    context.translate(body.position.x, body.position.y);
                    context.rotate(body.angle);
                    // Scale font size based on radius
                    const fontSize = fruit.radius * 1.2;
                    context.font = `${fontSize}px Arial`;
                    context.fillText(fruit.emoji, 0, 0);
                    context.restore();
                }
            }
        });

        // Input Handling
        let currentFruitX = 225; // Start center

        // Mouse Move / Touch Move to position the fruit
        gameArea.addEventListener("mousemove", (e) => {
            if (isGameOver || !canDrop) return;
            const rect = gameArea.getBoundingClientRect();
            updateCurrentFruitPosition(e.clientX - rect.left);
        });

        gameArea.addEventListener("touchmove", (e) => {
            if (isGameOver || !canDrop) return;
            const rect = gameArea.getBoundingClientRect();
            updateCurrentFruitPosition(e.touches[0].clientX - rect.left);
        });

        // Click / Touch End to drop
        gameArea.addEventListener("mouseup", () => dropFruit());
        gameArea.addEventListener("touchend", () => dropFruit());

        function updateCurrentFruitPosition(x) {
            const radius = FRUITS[nextFruitIndex].radius;
            // Clamp
            currentFruitX = Math.max(radius + 10, Math.min(x, 450 - radius - 10));
        }

        function dropFruit() {
            if (isGameOver || !canDrop) return;

            canDrop = false;
            const body = createFruit(currentFruitX, 50, nextFruitIndex);
            World.add(world, body);

            setTimeout(() => {
                canDrop = true;
                spawnNextFruit();
            }, 500);
        }

        // Render the "Preview" fruit
        Events.on(render, 'afterRender', function () {
            const context = render.context;

            // Draw the "Preview" fruit at top if canDrop is true
            if (canDrop && !isGameOver) {
                const fruit = FRUITS[nextFruitIndex];
                context.globalAlpha = 0.5; // Transparent preview
                context.fillStyle = fruit.color;
                context.beginPath();
                context.arc(currentFruitX, 50, fruit.radius, 0, 2 * Math.PI);
                context.fill();

                context.globalAlpha = 1.0;
                context.font = `${fruit.radius * 1.2}px Arial`;
                context.textAlign = "center";
                context.textBaseline = "middle";
                context.fillText(fruit.emoji, currentFruitX, 50);
            }
        });

        // Collision Handling (Merging)
        Events.on(engine, 'collisionStart', (event) => {
            const pairs = event.pairs;

            for (let i = 0; i < pairs.length; i++) {
                const bodyA = pairs[i].bodyA;
                const bodyB = pairs[i].bodyB;

                if (bodyA.label.startsWith('fruit_') && bodyB.label.startsWith('fruit_')) {
                    const indexA = parseInt(bodyA.label.split('_')[1]);
                    const indexB = parseInt(bodyB.label.split('_')[1]);

                    if (indexA === indexB && indexA < FRUITS.length - 1) {
                        // Merge!
                        const midX = (bodyA.position.x + bodyB.position.x) / 2;
                        const midY = (bodyA.position.y + bodyB.position.y) / 2;

                        World.remove(world, [bodyA, bodyB]);

                        // Add score
                        updateScore(FRUITS[indexA].score * 2);

                        // Create new fruit
                        const newFruit = createFruit(midX, midY, indexA + 1);
                        World.add(world, newFruit);
                    }
                }
            }
        });

        // Draw Limit Line
        Events.on(render, 'afterRender', function () {
            const context = render.context;
            context.beginPath();
            context.moveTo(0, 150);
            context.lineTo(450, 150);
            context.strokeStyle = "rgba(255, 118, 117, 0.5)"; // Soft red
            context.lineWidth = 4;
            context.setLineDash([10, 10]);
            context.stroke();

            // Add "DANGER" text small
            context.font = "12px 'Noto Sans KR'";
            context.fillStyle = "rgba(255, 118, 117, 0.8)";
            context.textAlign = "right";
            context.fillText("LIMIT", 440, 145);

            context.setLineDash([]);
            context.closePath();
        });

        // Game Over Check
        setInterval(() => {
            if (isGameOver) return;

            const bodies = Composite.allBodies(world);
            let danger = false;

            for (const body of bodies) {
                if (body.label.startsWith('fruit_') && body.speed < 0.2) {
                    if (body.label.startsWith('fruit_')) {
                        if (body.position.y - body.circleRadius < 150) {
                            danger = true;
                        }
                    }
                }
            }

            if (danger) {
                if (!window.gameOverTimer) window.gameOverTimer = 0;
                window.gameOverTimer += 1000;
                if (window.gameOverTimer > 3000) { // 3 seconds over the line
                    endGame();
                }
            } else {
                window.gameOverTimer = 0;
            }
        }, 1000);

        function updateScore(points) {
            score += points;
            scoreElement.innerText = score;
        }

        function endGame() {
            isGameOver = true;
            finalScoreElement.innerText = score;
            gameOverScreen.classList.remove("hidden");
        }

        restartBtn.addEventListener("click", initGame);

        // Start
        initGame();
    </script>
</body>

</html>